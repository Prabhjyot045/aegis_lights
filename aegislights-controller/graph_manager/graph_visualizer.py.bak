"""Live web-based graph visualization using Flask and Socket.IO.

Provides real-time browser-based visualization that updates as the MAPE loop runs.
Runs Flask server in separate thread to not block MAPE loop.
"""

import logging
from typing import Optional, Dict, List
from pathlib import Path
import threading
import json
import webbrowser
from flask import Flask, render_template
from flask_socketio import SocketIO
from flask_cors import CORS

from .graph_model import TrafficGraph
from config.visualization import VisualizationConfig

logger = logging.getLogger(__name__)


class GraphVisualizer:
    """
    Real-time web-based visualization of traffic graph state.
    
    Uses Flask + Socket.IO for live browser updates.
    Runs web server in separate thread to not block MAPE loop.
    """
    
    def __init__(self, graph: TrafficGraph, record: bool = False,
                 output_dir: Optional[Path] = None, port: int = 5001):
        """
        Initialize web-based graph visualizer.
        
        Args:
            graph: Traffic graph to visualize
            record: Whether to log updates (for future replay)
            output_dir: Directory for logs (if record=True)
            port: Web server port (default 5001, CityFlow uses 5000)
        """
        self.graph = graph
        self.config = VisualizationConfig()
        self.record = record
        self.output_dir = Path(output_dir) if output_dir else Path("output/visualization_logs")
        self.port = port
        
        self.running = False
        self._thread = None
        self._lock = threading.Lock()
        
        # Flask app and SocketIO
        self.app = Flask(__name__, 
                        template_folder=str(Path(__file__).parent / 'templates'),
                        static_folder=str(Path(__file__).parent / 'static'))
        CORS(self.app)
        self.socketio = SocketIO(self.app, cors_allowed_origins="*", async_mode='threading')
        
        # Metrics cache for display
        self._metrics_cache: Dict = {
            'cycle': 0,
            'incidents': 0,
            'adaptations': 0,
            'avg_delay': 0.0,
            'timestamp': 0.0
        }
        
        # Setup routes
        self._setup_routes()
        
        # Create output directory if recording
        if self.record:
            self.output_dir.mkdir(parents=True, exist_ok=True)
            logger.info(f"Visualization logs will be saved to: {self.output_dir}")
    
    def _setup_routes(self) -> None:
        """Setup Flask routes for web interface."""
        
        @self.app.route('/')
        def index():
            """Serve main visualization page."""
            return render_template('visualizer.html')
        
        @self.app.route('/api/graph')
        def get_graph():
            """API endpoint to get current graph state."""
            with self._lock:
                return json.dumps(self._get_graph_data())
        
        @self.app.route('/api/metrics')
        def get_metrics():
            """API endpoint to get current metrics."""
            with self._lock:
                return json.dumps(self._metrics_cache)
    
    def start(self) -> None:
        """
        Start the web-based visualizer in a separate thread.
        Non-blocking - allows MAPE loop to continue.
        Opens browser automatically.
        """
        if self.running:
            logger.warning("Visualizer already running")
            return
        
        self.running = True
        
        # Start Flask server in background thread
        self._thread = threading.Thread(target=self._run_server, daemon=True)
        self._thread.start()
        
        # Give server time to start
        import time
        time.sleep(1)
        
        # Open browser
        url = f"http://localhost:{self.port}"
        logger.info(f"Graph visualizer started at {url}")
        logger.info("Opening browser...")
        
        try:
            webbrowser.open(url)
        except Exception as e:
            logger.warning(f"Could not open browser automatically: {e}")
            logger.info(f"Please open manually: {url}")
    
    def _run_server(self) -> None:
        """Run Flask-SocketIO server (called in background thread)."""
        try:
            self.socketio.run(
                self.app,
                host='0.0.0.0',
                port=self.port,
                debug=False,
                use_reloader=False,
                log_output=False
            )
        except Exception as e:
            logger.error(f"Flask server error: {e}", exc_info=True)
    
    def stop(self) -> None:
        """Stop the visualizer and cleanup resources."""
        if not self.running:
            return
        
        self.running = False
        
        # Emit shutdown event to clients
        try:
            self.socketio.emit('shutdown', {'message': 'Visualizer stopped'})
        except:
            pass
        
        # Stop SocketIO
        try:
            self.socketio.stop()
        except:
            pass
        
        logger.info("Graph visualizer stopped")
    
    def update(self, graph: Optional[TrafficGraph] = None) -> None:
        """
        Update visualization with current graph state.
        Thread-safe - broadcasts to all connected browsers.
        
        Args:
            graph: Optional updated graph reference
        """
        if not self.running:
            return
        
        with self._lock:
            if graph:
                self.graph = graph
            
            try:
                # Get current graph data
                graph_data = self._get_graph_data()
                
                # Broadcast to all connected clients
                self.socketio.emit('graph_update', graph_data)
                
                # Log if recording enabled
                if self.record:
                    self._log_update(graph_data)
                    
            except Exception as e:
                logger.warning(f"Failed to update visualization: {e}")
    
    def update_metrics(self, cycle: int, incidents: int, adaptations: int, avg_delay: float) -> None:
        """
        Update metrics display cache.
        Thread-safe - broadcasts to all connected browsers.
        """
        import time
        
        with self._lock:
            self._metrics_cache = {
                'cycle': cycle,
                'incidents': incidents,
                'adaptations': adaptations,
                'avg_delay': avg_delay,
                'timestamp': time.time()
            }
        
        # Broadcast metrics update
        try:
            self.socketio.emit('metrics_update', self._metrics_cache)
        except Exception as e:
            logger.debug(f"Failed to broadcast metrics: {e}")
    
    def _initialize_plot(self) -> None:
        """Initialize matplotlib figure and compute layout."""
        try:
            self.fig, self.ax = plt.subplots(figsize=(16, 9), dpi=100)
            
            # Compute node positions using NetworkX layout
            nx_graph = self._to_networkx()
            
            if len(nx_graph.nodes) == 0:
                logger.warning("Graph has no nodes, using empty layout")
                self.pos = {}
                return
            
            # Choose layout algorithm
            try:
                if self.config.layout_algorithm == 'spring':
                    self.pos = nx.spring_layout(nx_graph, k=2, iterations=50, seed=42)
                elif self.config.layout_algorithm == 'circular':
                    self.pos = nx.circular_layout(nx_graph)
                else:  # kamada_kawai
                    self.pos = nx.kamada_kawai_layout(nx_graph)
            except Exception as e:
                logger.warning(f"Layout algorithm failed, using spring layout: {e}")
                self.pos = nx.spring_layout(nx_graph, seed=42)
            
            logger.info(f"Layout computed with {len(self.pos)} nodes using {self.config.layout_algorithm}")
            
            # Render initial frame
            if self.record:
                self._render_frame()
                
        except Exception as e:
            logger.error(f"Failed to initialize plot: {e}", exc_info=True)
            self.fig = None
            self.ax = None
            self.pos = {}
    
    def _render_frame(self) -> None:
        """
        Render a single frame of the visualization.
        Saves to PNG file (WSL-compatible).
        """
        if not self.ax or not self.pos:
            return
        
        try:
            self.ax.clear()
            self.ax.set_title(
                f"CityFlow Traffic Network - Cycle {self._metrics_cache['cycle']} | "
                f"Incidents: {self._metrics_cache['incidents']} | "
                f"Adaptations: {self._metrics_cache['adaptations']} | "
                f"Avg Delay: {self._metrics_cache['avg_delay']:.1f}s",
                fontsize=14, pad=20
            )
            self.ax.axis('off')
            
            # Convert to NetworkX for drawing
            nx_graph = self._to_networkx()
            
            if len(nx_graph.nodes) == 0:
                logger.debug("Empty graph, skipping render")
                return
            
            # Get node and edge attributes
            node_colors = []
            for node_id in self.pos.keys():
                if node_id in self.graph.nodes:
                    node_colors.append(self._get_node_color(self.graph.nodes[node_id]))
                else:
                    node_colors.append(self.config.node_color_normal)
            
            edge_colors = []
            edge_widths = []
            for edge_key in nx_graph.edges():
                if edge_key in self.graph.edges:
                    edge = self.graph.edges[edge_key]
                    edge_colors.append(self._get_edge_color(edge))
                    edge_widths.append(self._get_edge_width(edge))
                else:
                    edge_colors.append(self.config.edge_color_normal)
                    edge_widths.append(self.config.edge_width_base)
            
            # Draw edges
            if len(edge_colors) > 0:
                nx.draw_networkx_edges(
                    nx_graph, self.pos, ax=self.ax,
                    edge_color=edge_colors,
                    width=edge_widths,
                    arrows=True,
                    arrowsize=15,
                    arrowstyle='->',
                    connectionstyle='arc3,rad=0.1',
                    alpha=0.7
                )
            
            # Draw nodes
            nx.draw_networkx_nodes(
                nx_graph, self.pos, ax=self.ax,
                node_color=node_colors,
                node_size=self.config.node_size,
                node_shape=self.config.node_shape,
                edgecolors='black',
                linewidths=2,
                alpha=0.9
            )
            
            # Draw node labels
            nx.draw_networkx_labels(
                nx_graph, self.pos, ax=self.ax,
                font_size=10,
                font_weight='bold',
                font_color='black'
            )
            
            # Add edge labels with queue/delay metrics (only for edges in graph)
            edge_labels = {}
            for edge_key, edge in self.graph.edges.items():
                from_node, to_node = edge_key
                if (from_node, to_node) in nx_graph.edges():
                    label = f"Q:{edge.current_queue:.0f}\nD:{edge.current_delay:.1f}s"
                    edge_labels[(from_node, to_node)] = label
            
            if edge_labels:
                nx.draw_networkx_edge_labels(
                    nx_graph, self.pos, edge_labels, ax=self.ax,
                    font_size=7,
                    bbox=dict(boxstyle="round,pad=0.3", facecolor="white", 
                             edgecolor="gray", alpha=0.8)
                )
            
            # Add legend
            self._add_legend()
            
            # Add metrics panel
            if self.config.show_metrics_panel:
                self._add_metrics_panel()
            
            plt.tight_layout()
            
            # Save to file (WSL-compatible)
            output_file = self.output_dir / f"network_cycle_{self._metrics_cache['cycle']:04d}.png"
            self.fig.savefig(output_file, dpi=100, bbox_inches='tight')
            
            self._frame_count += 1
            
            if self._frame_count % 10 == 0:
                logger.debug(f"Rendered frame {self._frame_count} → {output_file}")
                
        except Exception as e:
            logger.warning(f"Failed to render frame: {e}")
    
    def create_video(self) -> None:
        """
        Create video from saved PNG frames using ffmpeg.
        Run this after experiment completes.
        """
        try:
            import subprocess
            
            input_pattern = self.output_dir / "network_cycle_%04d.png"
            output_video = self.output_dir / "traffic_network_animation.mp4"
            
            cmd = [
                'ffmpeg', '-y',
                '-framerate', '2',  # 2 frames per second
                '-i', str(input_pattern),
                '-c:v', 'libx264',
                '-pix_fmt', 'yuv420p',
                '-movflags', '+faststart',
                str(output_video)
            ]
            
            logger.info(f"Creating video from {self._frame_count} frames...")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                logger.info(f"Video created successfully: {output_video}")
            else:
                logger.warning(f"ffmpeg failed: {result.stderr}")
                
        except FileNotFoundError:
            logger.info("ffmpeg not found. Install with: sudo apt install ffmpeg")
        except Exception as e:
            logger.warning(f"Failed to create video: {e}")
    
    def _get_node_color(self, node) -> str:
        """Get color for node based on state."""
        if node.has_spillback:
            return self.config.node_color_spillback
        elif node.is_congested:
            return self.config.node_color_congested
        else:
            return self.config.node_color_normal
    
    def _get_edge_color(self, edge) -> str:
        """Get color for edge based on state."""
        if edge.incident_active:
            return self.config.edge_color_incident
        elif edge.edge_cost > 10.0:  # High cost threshold
            return self.config.edge_color_high_cost
        else:
            return self.config.edge_color_normal
    
    def _get_edge_width(self, edge) -> float:
        """Get edge width based on queue length."""
        return (
            self.config.edge_width_base + 
            edge.current_queue * self.config.edge_width_multiplier
        )
    
    def _to_networkx(self) -> nx.DiGraph:
        """Convert current graph state to NetworkX graph."""
        G = nx.DiGraph()
        
        # Add nodes
        for node_id in self.graph.nodes.keys():
            G.add_node(node_id)
        
        # Add edges
        for edge_key, edge in self.graph.edges.items():
            from_node, to_node = edge_key
            G.add_edge(from_node, to_node, weight=edge.edge_cost)
        
        return G
    
    def _add_legend(self) -> None:
        """Add color legend to plot."""
        legend_elements = [
            mpatches.Patch(color=self.config.node_color_normal, label='Normal Node'),
            mpatches.Patch(color=self.config.node_color_congested, label='Congested Node'),
            mpatches.Patch(color=self.config.node_color_spillback, label='Spillback Node'),
            mpatches.Patch(color=self.config.edge_color_normal, label='Normal Edge'),
            mpatches.Patch(color=self.config.edge_color_high_cost, label='High Cost Edge'),
            mpatches.Patch(color=self.config.edge_color_incident, label='Incident Edge')
        ]
        
        self.ax.legend(
            handles=legend_elements,
            loc='upper right',
            fontsize=10,
            framealpha=0.9
        )
    
    def _add_metrics_panel(self) -> None:
        """Add metrics text panel to plot."""
        metrics_text = (
            f"Network Status\n"
            f"─────────────\n"
            f"Total Nodes: {len(self.graph.nodes)}\n"
            f"Total Edges: {len(self.graph.edges)}\n"
            f"Congested: {len(self.graph.get_congested_nodes())}\n"
            f"Spillbacks: {len(self.graph.get_spillback_edges())}\n"
            f"Active Incidents: {self._metrics_cache['incidents']}"
        )
        
        self.ax.text(
            0.02, 0.98,
            metrics_text,
            transform=self.ax.transAxes,
            fontsize=10,
            verticalalignment='top',
            bbox=dict(boxstyle='round', facecolor='white', alpha=0.9),
            family='monospace'
        )
